% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SampleBinaryMatrices.R
\name{SampleInterval}
\alias{SampleInterval}
\title{Create random binary matrices whose row and column sums are bounded by prescribed integers.}
\usage{
SampleInterval(rowsum.lower, rowsum.upper, colsum.lower, colsum.upper, samples,
  method = "exact", steps = NULL)
}
\arguments{
\item{rowsum.lower}{Integer vector defining the lower bounds on each row sum.}

\item{rowsum.upper}{Integer vector defining the upper bounds on each row sum.}

\item{colsum.lower}{Integer vector defining the lower bounds on each column sum.}

\item{colsum.upper}{Integer vector defining the upper bounds on each column sum.}

\item{samples}{Number of samples to produce.}

\item{method}{Sampling algorithm. Must be one of the following
"exact": Use a sampling algorithm that is proven to produce uniformly distributed samples. However, this algorithm may have an unpleasent running time.
"simple": Simulation of the first Markov chain defined in Rechner et al.: 'Uniform sampling of bipartite graphs with degrees in prescribed intervals'. Journal of Complex Networks (2017).
"informed": Simulation of the second Markov chain defined in Rechner et al.: 'Uniform sampling of bipartite graphs with degrees in prescribed intervals'. Journal of Complex Networks (2017).}

\item{steps}{Number of steps. (Larger is better.)
If \code{method} is "exact", no \code{steps} argument is required.}
}
\value{
A list of binary matrices.
}
\description{
The function \code{SampleInterval} produces \code{N} random binary matrices whose row and column sums lie in prescribed intervals.
Each matrix is drawn uniformly from the set of binary matrices that meet these conditions.
The sampling method can be specified by the \code{method} parameter. As the "simple" and "informed" sampling methods are based on the simulation of a Markov chain, 
they require an assumption on the number of \code{steps} that is neccessary to produce random samples. 
In contrast, an \code{exact} method may be used to produce random samples without having to rely on the number of steps.
}
\examples{
# First, we need to define the lower and upper bounds on the row and column sums of the binary matrices
# we want to produce, e.g.

rowsum.lower <- c(1, 0, 1)
rowsum.upper <- c(2, 1, 1)
colsum.lower <- c(0, 1, 1, 0)
colsum.upper <- c(1, 1, 2, 3).

# To use the 'exact' sampling method (which may be costly for large instances), we just
# pass the lower and upper bounds on the row and column sums in addition to the number of samples we require. Here, we want to create 100 independent matrices

l <- SampleInterval(rowsum.lower, rowsum.upper, colsum.lower, colsum.upper, 100, method="exact")

For large instances, the running time of the exact sampling method may become unpleasently high. In such cases, it is better to use 
one of the other sampling algorithms. In this case, we need to specify a number of 'steps'. 
It is hard to define a general rule on how to choose this parameter. In general, the larger this value is, the more independent will the binary matrices be. 

l <- SampleInterval(rowsum.lower, rowsum.upper, colsum.lower, colsum.upper, 100, method="simple", steps=100)

}
